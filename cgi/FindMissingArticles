#!/usr/local/bin/perl -w

use strict;
use FindBin;
use lib "$FindBin::Bin/../lib/perl";

use JSON;
use XML::Writer;
use ProteomeXchange::Dataset;
use ProteomeXchange::DatasetParser;
use ProteomeXchange::ArticleFinder;

$| = 1;
use CGI qw/:standard/;
my $cgi = new CGI;

our $CGI_BASE_DIR = $cgi->new->url();
$CGI_BASE_DIR =~ s/cgi.*/cgi/;

my $response = {};
$response->{result} = "ERROR";
$response->{message} = "ERROR: Unhandled exception E001";
my @tmp = ( 'Dataset service start' );
$response->{info} = \@tmp;

my $params;

my @parameters = qw ( test verbose ID outputMode detailLevel);
our @page;
use LWP::UserAgent;
use HTTP::Request;
my $ua = LWP::UserAgent->new();

my $articleFinder = new ProteomeXchange::ArticleFinder;

#### Extract CGI parameters
foreach my $parameter ( @parameters ) {
  if ($cgi->param($parameter)) {
    $params->{$parameter} = $cgi->param($parameter);
  	push(@{$response->{info}},"Found input parameter $parameter=$params->{$parameter}") if ($cgi->param('verbose'));
  }
}

my $skinLink = 'http://proteomecentral.proteomexchange.org/template.php';
$response = $ua->request( HTTP::Request->new( GET => "$skinLink" ) );
if ( $response -> is_success()){
  @page = split( "\n", $response->content() );
}else{
  $response->{message} = "unable to open template http://proteomecentral.proteomexchange.org/template.php\n";
  exit;
}

#### Also extract command-line parameters, useful for testing
foreach my $arg ( @ARGV ) {
  if ( $arg =~ /(\S+)=(\S+)/) {
    my $key = $1;
	  my $value = $2;
		foreach my $parameter ( @parameters ) {
			if ($key eq $parameter) {
				$params->{$parameter} = $value;
				push(@{$response->{info}},"Found input parameter $key=$value");
			}
		}
  }# else {
   #  $response->{message} = "ERROR: Unable to parse method line parameter '$arg'\n";
	 #  exit;
  #}
}

$response->{verbose} = $params->{verbose};

searchAnnouncedDatasets(params=>$params,response=>$response);

exit;


###############################################################################
# sendResponse
###############################################################################
sub sendResponse {
  my %args = @_;
  my $SUB_NAME = 'sendResponse';

  #### Decode the argument list
  my $response = $args{'response'} || die("[$SUB_NAME] ERROR: response not passed");

  print "Content-type: text/plain\n\n";

  print "result=$response->{result}\n";
  print "message=$response->{message}\n" if ($response->{result});
  print "identifier=$response->{identifier}\n" if ($response->{identifier});

  #if ($response->{info} && $response->{verbose}) {
  if ($response->{info}) {
    foreach my $line (@{$response->{info}}) {
      print "info=$line\n";
	}
  }
	
  exit;
}


###############################################################################
# searchAnnouncedDatasets
###############################################################################
sub searchAnnouncedDatasets {
  my %args = @_;
  my $SUB_NAME = 'searchAnnouncedDatasets';
   
  #### Decode the argument list
  my $params = $args{'params'}; 
  my $response = $args{'response'} || die("[$SUB_NAME] ERROR: response not passed");
  my $test = $params->{test} || 'no';
  my $outputMode=$params->{outputMode} || 'html';
  my $table_name = 'dataset';
  my $teststr = '';

  if ($test && ($test =~ /yes/i || $test =~ /true/i)){
    $teststr = "&test=$test";
    $table_name = 'dataset_test' 
  }

  my $dbh = new ProteomeXchange::Database;
  my $whereclause = 'WHERE status = "announced"';
  my %hidden_cols = ();
  my @headings = (); 

  my  @column_array =(
        ["datasetIdentifier","Dataset Identifier"],
        ["PXPartner","Repository"],
        ["status","Status"],
        ["primarySubmitter","Primary Submitter"],
        ["labHead", "LabHead"],
        ["title","Title"],
        ["publication","Publication"],
        );

  my $columns_clause =  build_SQL_columns_list(
       	column_array_ref=>\@column_array,
        hidden_cols_ref => \%hidden_cols,
        heading => \@headings);

  my $sql = qq~ select
        $columns_clause 
        from $table_name
        $whereclause
        ORDER BY datasetIdentifier DESC
  ~;

  my @results = $dbh->selectSeveralColumns($sql);

  if ($outputMode =~ /html/i){
    print "Content-type:text/html\r\n\r\n";
    foreach my $line (@page){
      if($line =~ /(TEMPLATESUBTITLE|TEMPLATETITLE)/){
	$line =~ s/$1/ProteomeXchange Datasets/;
	print "$line\n";
      } elsif($line =~ /class="node-inner-padding"/){
	#$line =~ s/>/style="padding: 0">/g;
	print "$line\n";
      } elsif ($line =~ /^<!-- BEGIN main content -->/){
	print "$line\n";

	print "<H1>Searching announced datasets for possibly associated articles...</H1>\n";

	#### Iterate through the datasets, looking for possible matches
	my $counter = 0;
	my %stats;
	foreach my $values (@results){
	  $counter++;
	  #last if ($counter > 100);
	  #next unless ($values->[0] eq 'PXD000246');

	  if ($values->[6] =~ /href/) {
	    $stats{'Datasets already with an assoctiated PubMed ID'}++;
	    next;
	  }

	  my $buffer ='';


	  $buffer .= "<HR>\n";
	  $buffer .= "<a href=\"http://proteomecentral.proteomexchange.org/dataset/$values->[0]\">$values->[0]</a> \t$values->[6] (from $values->[1])<BR>\n";

	  #print "Searching for $values->[0]: $values->[5]\n";

	  my $searchResult = $articleFinder->findArticle(title=>$values->[5]);

	  #### If nothing was found
	  if ( $searchResult->{message} eq 'No articles found' || $searchResult->{year} < 2012) {
	    $stats{"Datasets of status '$values->[6]' with no articles found"}++;
	    next;
	  }

	  $buffer .= "<B>Dataset title:</B> $values->[5]<BR>";

	  my $referenceString = $searchResult->{referenceString};
	  $referenceString =~ s#PMID (\d+)#<a href="http://www.ncbi.nlm.nih.gov/pubmed/?term=$1">PMID $1</a>#;

	  $buffer .= "<B>Possible reference:</B> $referenceString\n";
	  $stats{"Datasets of status '$values->[6]' with a possible article found"}++;
	  print $buffer;
	}

	print "<BR><BR><HR><BR>Summary of results:<BR>\n";
	foreach my $key ( sort keys(%stats) ) {
	  print "$stats{$key} $key<BR>\n";
	}
	print "<BR><BR>\n";


      } elsif($line =~ /<\/body/){
        print "$line\n";
      } else{
        print "$line\n";
      }
    }

  #### Print the result in XML
  } elsif($outputMode=~ /xml/i){
     print "Content-type:text/xml\r\n\r\n";
     my $writer = new XML::Writer(DATA_MODE => 1, DATA_INDENT => 4,ENCODING=>'UTF-8',);
     $writer->xmlDecl("UTF-8");
     $writer->startTag("ProteomeXchangeDataset",
        "xmlns:xsi"=>"http://www.w3.org/2001/XMLSchema-instance",
        "xsi:noNamespaceSchemaLocation"=>"proteomeXchange-draft-05.xsd",
        "formatVersion"=>"1.0.0",
      );

     foreach my $values (@results) {
       $headings[0] =~ s/\s+/_/g; 
       $writer->startTag($headings[0], ,id=>"$values->[0]");
       for (my $i=1;$i<=$#headings;$i++){
        $headings[$i] =~ s/\s+/_/g;
        $writer->startTag($headings[$i],);
        $writer->characters($values->[$i]);
        $writer->endTag($headings[$i]);
       }
       $writer->endTag($headings[0]);
     } 
     $writer->endTag("ProteomeXchangeDataset");
     $writer->end();

  #### Print the result as a TSV table
  } elsif($outputMode=~ /tsv/i){
    print "Content-type:text/plain\r\n\r\n";
    foreach my $h (@headings){
     print "$h\t";
    }
    print "\n";
    foreach my $values (@results){
     print join("\t", @$values);
     print "\n";
   }
  }
}


###############################################################################
# build_SQL_columns_list
###############################################################################
sub build_SQL_columns_list {
  my %args = @_;
  my $METHOD = 'build_SQL_columns_list';
  #### Process the arguments list
  my $column_array_ref = $args{'column_array_ref'} ||
    die "$METHOD: column_array_ref not passed!";
  my $hidden_cols_ref = $args{'hidden_cols_ref'};
  my $heading = $args{'heading'};

  my $columns_clause = "";
  my $element;
  foreach $element (@{$column_array_ref}) {
    next if ( defined $hidden_cols_ref->{$element->[1]});
    $columns_clause .= "," if ($columns_clause);
    $columns_clause .= "$element->[0]";

    push @$heading , $element->[1];
  }
  #### Return result
  return $columns_clause;

} # end build_SQL_columns_list


###############################################################################
# searchUnannouncedDatasets
###############################################################################
sub searchUnannouncedDatasets {
  my %args = @_;
  my $SUB_NAME = 'searchUnannouncedDatasets';
   
  #### Decode the argument list
  my $params = $args{'params'}; 
  my $response = $args{'response'} || die("[$SUB_NAME] ERROR: response not passed");
  my $test = $params->{test} || 'no';
  my $outputMode=$params->{outputMode} || 'html';
  my $table_name = 'dataset';
  my $teststr = '';

  if ($test && ($test =~ /yes/i || $test =~ /true/i)){
    $teststr = "&test=$test";
    $table_name = 'dataset_test' 
  }

  my $dbh = new ProteomeXchange::Database;
  my $whereclause = 'WHERE status = "ID requested"';
  my %hidden_cols = ();
  my @headings = (); 

  my  @column_array =(
        ["datasetIdentifier","Dataset Identifier"],
        ["PXPartner","Repository"],
        ["status","Status"],
        ["primarySubmitter","Primary Submitter"],
        ["labHead", "LabHead"],
        ["title","Title"],
        ["publication","Publication"],
        );

  my $columns_clause =  build_SQL_columns_list(
       	column_array_ref=>\@column_array,
        hidden_cols_ref => \%hidden_cols,
        heading => \@headings);

  my $sql = qq~ select
        $columns_clause 
        from $table_name
        $whereclause
        ORDER BY datasetIdentifier DESC
  ~;

  my @results = $dbh->selectSeveralColumns($sql);

  if ($outputMode =~ /html/i){
    print "Content-type:text/html\r\n\r\n";
    foreach my $line (@page){
      if($line =~ /(TEMPLATESUBTITLE|TEMPLATETITLE)/){
	$line =~ s/$1/ProteomeXchange Datasets/;
	print "$line\n";
      } elsif($line =~ /class="node-inner-padding"/){
	#$line =~ s/>/style="padding: 0">/g;
	print "$line\n";
      } elsif ($line =~ /^<!-- BEGIN main content -->/){
	print "$line\n";

	print "<H1>Searching unannounced datasets for possibly associated articles...</H1>\n";

	#### Iterate through the datasets, looking for possible matches
	my $counter = 0;
	my %stats;
	foreach my $values (@results){
	  $counter++;
	  last if ($counter > 20);
	  #next unless ($values->[0] eq 'PXD000246');

	  my $buffer ='';

	  $buffer .= "<HR>\n";
	  $buffer .= "<a href=\"http://proteomecentral.proteomexchange.org/dataset/$values->[0]\">$values->[0]</a> \t$values->[6] (from $values->[1])<BR>\n";

	  print "Searching for $values->[0]: $values->[5]\n";

	  my $searchResult = $articleFinder->findArticle(title=>$values->[5]);

	  #### If nothing was found
	  if ( $searchResult->{message} eq 'No articles found' || $searchResult->{year} < 2012) {
	    $stats{"Datasets of status '$values->[6]' with no articles found"}++;
	    next;
	  }

	  $buffer .= "<B>Dataset title:</B> $values->[5]<BR>";

	  my $referenceString = $searchResult->{referenceString};
	  $referenceString =~ s#PMID (\d+)#<a href="http://www.ncbi.nlm.nih.gov/pubmed/?term=$1">PMID $1</a>#;

	  $buffer .= "<B>Possible reference:</B> $referenceString\n";
	  $stats{"Datasets of status '$values->[6]' with a possible article found"}++;
	  print $buffer;
	}

	print "<BR><BR><HR><BR>Summary of results:<BR>\n";
	foreach my $key ( sort keys(%stats) ) {
	  print "$stats{$key} $key<BR>\n";
	}
	print "<BR><BR>\n";


      } elsif($line =~ /<\/body/){
        print "$line\n";
      } else{
        print "$line\n";
      }
    }

  #### Print the result in XML
  } elsif($outputMode=~ /xml/i){
     print "Content-type:text/xml\r\n\r\n";
     my $writer = new XML::Writer(DATA_MODE => 1, DATA_INDENT => 4,ENCODING=>'UTF-8',);
     $writer->xmlDecl("UTF-8");
     $writer->startTag("ProteomeXchangeDataset",
        "xmlns:xsi"=>"http://www.w3.org/2001/XMLSchema-instance",
        "xsi:noNamespaceSchemaLocation"=>"proteomeXchange-draft-05.xsd",
        "formatVersion"=>"1.0.0",
      );

     foreach my $values (@results) {
       $headings[0] =~ s/\s+/_/g; 
       $writer->startTag($headings[0], ,id=>"$values->[0]");
       for (my $i=1;$i<=$#headings;$i++){
        $headings[$i] =~ s/\s+/_/g;
        $writer->startTag($headings[$i],);
        $writer->characters($values->[$i]);
        $writer->endTag($headings[$i]);
       }
       $writer->endTag($headings[0]);
     } 
     $writer->endTag("ProteomeXchangeDataset");
     $writer->end();

  #### Print the result as a TSV table
  } elsif($outputMode=~ /tsv/i){
    print "Content-type:text/plain\r\n\r\n";
    foreach my $h (@headings){
     print "$h\t";
    }
    print "\n";
    foreach my $values (@results){
     print join("\t", @$values);
     print "\n";
   }
  }
}


