#!/usr/local/bin/perl -w

use strict;
use FindBin;
use lib "$FindBin::Bin/../lib/perl";

use JSON;
use XML::Writer;
use ProteomeXchange::Dataset;
use ProteomeXchange::DatasetParser;
$| = 1;
use CGI qw/:standard/;
my $cgi = new CGI;

our $CGI_BASE_DIR = $cgi->new->url();
$CGI_BASE_DIR =~ s/cgi.*/cgi/;

my $response = {};
$response->{result} = "ERROR";
$response->{message} = "ERROR: Unhandled exception E001";
my @tmp = ( 'Dataset service start' );
$response->{info} = \@tmp;

my $params;

my @parameters = qw ( test verbose ID outputMode detailLevel);
our @page;
use LWP::UserAgent;
use HTTP::Request;
my $ua = LWP::UserAgent->new();


#### Extract CGI parameters
foreach my $parameter ( @parameters ) {
  if ($cgi->param($parameter)) {
    $params->{$parameter} = $cgi->param($parameter);
  	push(@{$response->{info}},"Found input parameter $parameter=$params->{$parameter}") if ($cgi->param('verbose'));
  }
}
my $skinLink = 'http://proteomecentral.proteomexchange.org/template.php';
$response = $ua->request( HTTP::Request->new( GET => "$skinLink" ) );
if ( $response -> is_success()){
  @page = split( "\n", $response->content() );
}else{
  $response->{message} = "unable to open template http://proteomecentral.proteomexchange.org/template.php\n";
  exit;
}

#### Also extract command-line parameters, useful for testing
foreach my $arg ( @ARGV ) {
  if ( $arg =~ /(\S+)=(\S+)/) {
    my $key = $1;
	  my $value = $2;
		foreach my $parameter ( @parameters ) {
			if ($key eq $parameter) {
				$params->{$parameter} = $value;
				push(@{$response->{info}},"Found input parameter $key=$value");
			}
		}
  }# else {
   #  $response->{message} = "ERROR: Unable to parse method line parameter '$arg'\n";
	 #  exit;
  #}
}

$response->{verbose} = $params->{verbose};

#### Handle a dataset identifier
if ($params->{ID}  and $params->{ID} ne '') {
  showDataset(params=>$params,response=>$response);
}else{
  listDatasets(params=>$params,response=>$response);
}


exit;


###############################################################################
# sendResponse
###############################################################################
sub sendResponse {
  my %args = @_;
  my $SUB_NAME = 'sendResponse';

  #### Decode the argument list
  my $response = $args{'response'} || die("[$SUB_NAME] ERROR: response not passed");

  print "Content-type: text/plain\n\n";

  print "result=$response->{result}\n";
  print "message=$response->{message}\n" if ($response->{result});
  print "identifier=$response->{identifier}\n" if ($response->{identifier});

  #if ($response->{info} && $response->{verbose}) {
  if ($response->{info}) {
    foreach my $line (@{$response->{info}}) {
      print "info=$line\n";
	}
  }
	
  exit;
}


###############################################################################
# listDatasets
###############################################################################
sub listDatasets {
  my %args = @_;
  my $SUB_NAME = 'listDatasets';
   
  #### Decode the argument list
  my $params = $args{'params'}; 
  my $response = $args{'response'} || die("[$SUB_NAME] ERROR: response not passed");
  my $test = $params->{test} || 'no';
  my $outputMode=$params->{outputMode} || 'html';
  my $extended = $params->{detailLevel} || '0';
  my $table_name = 'dataset';
  my $teststr = '';

  if ($test && ($test =~ /yes/i || $test =~ /true/i)){
    $teststr = "&test=$test";
    $table_name = 'dataset_test' 
  }

	my $dbh = new ProteomeXchange::Database;
  my $whereclause = '';
  my %hidden_cols = ();
  my @headings = (); 
  
  if ($extended !~ /extended/i){
    $whereclause = "where status != 'ID requested'";
    %hidden_cols = (
                  "Status" => 1,
                  "Identifier Date"=> 1,
                  "Revision Date" => 1,);
  }

  my  @column_array =(
        ["datasetIdentifier","Dataset Identifier"],
        ["PXPartner","Repository"],
        ["status","Status"],
        ["primarySubmitter","Primary Submitter"],
        ["labHead", "LabHead"],
        ["title","Title"],
        ["species","Species"],
        ["instrument","Instrument"],
        ["publication","Publication"],
        ["DATE_FORMAT(identifierDate,'\%Y-\%m-\%d')","Identifier Date"],
        ["DATE_FORMAT(submissionDate,'\%Y-\%m-\%d')","Announcement Date"],
        ["DATE_FORMAT(revisionDate,'\%Y-\%m-\%d')","Revision Date"],
        );

  my $columns_clause =  build_SQL_columns_list(
				column_array_ref=>\@column_array,
        hidden_cols_ref => \%hidden_cols,
        heading => \@headings);

	my $sql = qq~ select
                 $columns_clause 
                 from $table_name
                 $whereclause
             ~;
	my @results = $dbh->selectSeveralColumns($sql);

  #### If the output mode is HTML, then render a JavaScript-based table of the data
  if ($outputMode =~ /html/i){
    print "Content-type:text/html\r\n\r\n";
    foreach my $line (@page){
      if ($line =~ /(TEMPLATESUBTITLE|TEMPLATETITLE)/){
	$line =~ s/$1/ProteomeXchange Datasets/;
	print "$line\n";
      } elsif($line =~ /class="node-inner-padding"/){
	#$line =~ s/>/style="padding: 0">/g;
	print "$line\n";
      } elsif ($line =~ /^<!-- BEGIN main content -->/){
	print "$line\n"; 
        my $col_options = qq~ ;
					<option value="Title">Title</option>
					<option value="id">Dataset ID</option>
					<option value="AnnouncementDate">Date</option>
					<option value="Instrument">Instrument</option>
					<option value="Labhead">Lab Head</option>
          <option value="Publication">Publication</option>
					<option value="Repository">Repository</option>
					<option value="Species">Species</option>
					<option value="Psubmitter">Submitter</option>
         ~;

         my $cond_options = qq~;
          <option value="contain">Contains</option>
          <option value="notcontain">Does not contain</option>
          <option value="exactly">Is exactly</option>
          <option value="less">Is less than</option>
          <option value="greater">Is greater than</option>
         ~;
					 my $str = qq~
            <div class="wrapper">
            <link rel="stylesheet" type="text/css" href="$CGI_BASE_DIR/../javascript/ext/css/ext-all.css"/>
            <link rel="stylesheet" type="text/css" href="$CGI_BASE_DIR/../javascript/ext/css/grid.css"/>
            <link rel="stylesheet" type="text/css" href="$CGI_BASE_DIR/../javascript/css/button.css"/>
            <script type="text/javascript" src="$CGI_BASE_DIR/../javascript/ext/jquery-1.8.0.min.js"></script> 
            <script type="text/javascript" src="$CGI_BASE_DIR/../javascript/ext/ext-4.0.7-gpl/bootstrap.js"></script>
            <script type="text/javascript" src="$CGI_BASE_DIR/../javascript/ext/RowExpander.js"></script>
            <script type="text/javascript" src="$CGI_BASE_DIR/../javascript/ext/AsyncRowExpander.js"></script>
            <script type="text/javascript" src="$CGI_BASE_DIR/../javascript/ext/grid.js"></script>
            <script type="text/javascript" src="$CGI_BASE_DIR/../javascript/toggle.js"></script>

            &nbsp;Below is a listing of publicly accessible ProteomeXchange datasets. Additional datasets will become visible as they are released.<BR><BR>
            <font face="Calibri">
            <div style="color:red;" id='basic_search' 
             onclick='toggle_more("basic_search","advanced_search","buildQuery","searchContainer")'>
             &nbsp;&nbsp;&nbsp;&nbsp;[Go to Advanced Search]</div>
            <div id='advanced_search' onclick='toggle_less("advanced_search","basic_search","buildQuery","searchContainer")' 
                 style='display:none; color:red;'>&nbsp;&nbsp;&nbsp;&nbsp;[Go back to Basic free-text Search]</div><BR>
            <div id='buildQuery' style='display: none; font-size:14px;'>
            &nbsp;&nbsp;&nbsp;&nbsp;Build your metadata query constraints below. Note that it is not yet possible to query for individual proteins:
            <div style="padding:30px; font-size:18px;"><a style="color:red;" id="error"></a>
							<table cellpadding="10" >
            ~;
            my $cnt = 1;
            foreach my $sel ( qw(
                                 Title 
                                 Instrument 
                                 Publication
                                 AnnouncementDate 
                                  )){
              my $options2 = $cond_options;
              if ($sel !~ /date/i){
                $options2 =~ s/value="greater"/value="greater" disabled/;
                $options2 =~ s/value="less"/value="less" disabled/;
              }
              if($cnt == 1){
   							$str .= qq~<tr><td align="position" valign="position" height="35">
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
								  <select id="sel_col1" onchange="configureDropDownList(this,'sel_con1')">$col_options</select>
                  </td><td>&nbsp;
                  <select id="sel_con1">$options2</select>
                  </td>
								  <td>&nbsp;<input type="text" id="sel1"></input></td></tr>
                ~;
              }else{
                my $options = $col_options;
                $options =~ s/(value="$sel")/$1 selected="selected"/;
                $str .= qq~
							    <tr><td height="35">
                  AND&nbsp;&nbsp; 
                  <select id="sel_col$cnt" onchange="configureDropDownList(this, \'sel_con$cnt\')">$options</select>
                  </td><td>&nbsp;
                  <select id="sel_con$cnt">$options2</select>
                  </td>
                  <td>&nbsp;<input type="text" id="sel$cnt"></input></td>
                ~;
                if($cnt == 4){
                  $str .= qq~
                    <td>&nbsp;&nbsp;<input type="button" name="advsearchbtn" id="advsearchbtn" value="Advanced Search"/>
                    &nbsp;&nbsp;<input  type="button" name="clear" id="clear" value="Clear"/>
                    </tr>
                  ~;
                }else{
                    $str .= "</tr>";
                }
              }
              $cnt++;
            }
            $str .= qq~
							</table>
            </div></div></font>
						<div id="searchContainer"> 
            Search metadata for ProteomeXchange datasets: (e.g. "liver", "musculus", "5600", etc.)<BR>
						<input type="text" id="field" id="s" name="q">
						<div id="delete"><span id="x">x</span></div></input>
						<input type="button" name="searchbtn" id="searchbtn" value="Search" /><BR>
            Note: it is not yet possible to query for individual proteins contained in these datasets at ProteomeCentral.<BR>
            <a href="http://www.proteomexchange.org/storys/how-get-informed-new-datasets-available-proteomexchange"><img width="50" height="15" src="/devED/images/subscribe_button-small.jpg"><font size="+1" color="#aa0000">Subscribe to receive all new ProteomeXchange announcements!</font></a>
						</div>
						<table cellpadding="0" width="100%" align="center" cellspacing="0" id="br1owseWrapper">
						<tr>
							<td valign="top">
							 <div class="datagrid">
								<div id="center"></div>
								</div> 
							</td>
							</tr>
						</table>
            </div>
            <div class="footer"  align="center">
        ~;

        print "$str\n";

      }elsif($line =~ /<\/body/){
        print "</div>$line\n";

      }else{
        print "$line\n";
      }
    }

  #### Else if the output mode is request to be XML, write out the tabular data as XML
  } elsif ($outputMode=~ /xml/i) {
     print "Content-type:text/xml\r\n\r\n";
     my $writer = new XML::Writer(DATA_MODE => 1, DATA_INDENT => 4,ENCODING=>'UTF-8',);
     $writer->xmlDecl("UTF-8");
     $writer->startTag("ProteomeXchangeDataset",
        "xmlns:xsi"=>"http://www.w3.org/2001/XMLSchema-instance",
        "xsi:noNamespaceSchemaLocation"=>"proteomeXchange-draft-05.xsd",
        "formatVersion"=>"1.0.0",
      );

     foreach my $values (@results) {
       $headings[0] =~ s/\s+/_/g; 
       $writer->startTag($headings[0], ,id=>"$values->[0]");
       for (my $i=1;$i<=$#headings;$i++){
        $headings[$i] =~ s/\s+/_/g;
        $writer->startTag($headings[$i],);
        $writer->characters($values->[$i]);
        $writer->endTag($headings[$i]);
       }
       $writer->endTag($headings[0]);
     } 
     $writer->endTag("ProteomeXchangeDataset");
     $writer->end();
  }elsif($outputMode=~ /tsv/i){
    print "Content-type:text/plain\r\n\r\n";
    foreach my $h (@headings){
     print "$h\t";
    }
    print "\n";
    foreach my $values (@results){
     print join("\t", @$values);
     print "\n";
   }
  }
}


###############################################################################
# showDataset
###############################################################################
sub showDataset {
  my %args = @_;
  my $SUB_NAME = 'showDataset';
  #### Decode the argument list
  my $params = $args{'params'} || die("[$SUB_NAME] ERROR: params not passed");
  my $response = $args{'response'} || die("[$SUB_NAME] ERROR: response not passed");
  my $outputmode = $params->{outputMode} || '';
  my $datasetID = $params->{ID} || die("[$SUB_NAME] ERROR: datasetID not passed");
  my $test = $params->{test} || 'no';

  my $table_name = 'dataset';
  my $path = '/local/wwwspecial/proteomecentral/var/submissions';
  my $teststr = '';

  if ($test && ($test =~ /yes/i || $test =~ /true/i)){
    $table_name = 'dataset_test';
    $path .= "/testing";
    $teststr = "?test=$test";
  }
 
  my $prefix = ''; 
  if (($datasetID =~ /^(R?PXD)/ && $teststr eq '') || 
      ($datasetID =~ /^(R?PXT)/ && $teststr ne '')) {
    $prefix = $1;
    $datasetID =~ s/$prefix//;
    $datasetID =~ s/^0+//;
  }

  my ($title,$status,$PXPartner,$announcementXML,$identifierDate,$datasetIdentifier,$datasetTitle);
  my ($datasetSubmitter,$datasetLabHead,$datasetSpeciesString);

  my $pageStatus = 'OK';
  my $str = '';
  $title  = $params->{ID};

  #### If a valid identifier was not obtained
  if ( $datasetID !~ /^\d+$/){
    $str = "The input identifier is not valid and should be of the form PXDnnnnnn or numbers only.";
    $pageStatus = 'ERROR';
  }

  if ($pageStatus eq 'OK') {
    my $len = 9 - length($datasetID);
    $title = substr ($prefix."000001",0, $len) . "$datasetID";
    #### Fetch results from dataset table
    my $dbh = new ProteomeXchange::Database;
    my $sql = qq~
               select datasetIdentifier
               from $table_name 
               where dataset_id in (
               select dataset_id
               from $table_name 
               where datasetOrigin like '%$title%')
              ~;
    my @derivedDatasets = $dbh->selectOneColumn($sql);
    $sql = qq~ 
                  select status,
                        PXPartner,
                        announcementXML,
                       identifierDate,
                       datasetIdentifier,
                       datasetOrigin
                  from $table_name 
                  where dataset_id=$datasetID
              ~;
    my @results = $dbh->selectSeveralColumns($sql);
    
    #### If no row was returned, then this identifer must not have been assigned yet
    if ( scalar(@results) == 0) {
      $str = "The identifier $title has not yet been assigned. Please check the identifier and type it in again.";
      $pageStatus = 'ERROR';
    }
    #### If more than one row is returned, this suggests database corruption or some other problem
    if ( scalar(@results) > 1) {
      $str = "Too many rows returned. Please report error GDSsD0001 to administrator.";
      $pageStatus = 'ERROR';
    }

    if ( $pageStatus eq 'OK' ) {
      ($status,$PXPartner,$announcementXML,$identifierDate,$datasetIdentifier) = @{$results[0]};
      $title = $datasetIdentifier;

      #print "Content-Type: text/html\n\nLooking for data file <BR>\n";
      #print "Looking for data file $path/$announcementXML<BR>\n";

      my $parser = new ProteomeXchange::DatasetParser;
      $parser->parse('announcementXML' => $announcementXML, 'response' => $response, filename=> "$path/$announcementXML" );
      my $result = $response->{dataset};

      my $header;

      $str .= "<p> <b>DataSet Summary</b> </p>\n<ul>";
      foreach my $key ( qw( PXPartner announceDate announcementXML DigitalObjectIdentifier ReviewLevel 
			    datasetOrigin derivedDataset RepositorySupport primarySubmitter title 
			    description speciesList modificationList instrument ) ) {

        $header =  ucfirst($key);  

	$datasetTitle = $result->{$key} if ($key eq 'title');
        $datasetSpeciesString = $result->{$key} if ($key eq 'speciesList');

        if ($header eq 'PXPartner'){
          $header = 'HostingRepository';
					$result->{$key} = $PXPartner unless ($result->{$key});
        }

        if ($key eq 'announcementXML'){
          $str .= qq~
                <li><b>$header</b>: <a href='GetDataset?ID=$datasetID&outputMode=XML&test=$test'>$result->{$key}</a></li>
                ~;
        } elsif ($key eq 'DigitalObjectIdentifier') {
          $str .= qq~<li><b>$header</b>: <a href="$result->{$key}">$result->{$key}</a></li>~;
        }elsif ($key eq 'derivedDataset'){
           if(@derivedDatasets){
             $str .= '<li><b>Reprocessed datasets that are derived from this dataset</b>: ';
             foreach my $acc (@derivedDatasets){
               $str .=  "<a href=\"GetDataset?ID=$acc&test=$test\">$acc<\/a> " ;
             }
             $str .='</li>';
           }
        }elsif($key eq 'datasetOrigin'){
           if($result->{$key} =~ /ProteomeXchange accession.*PXD\d+/i){
             $result->{$key} =~ s#(PXD\d+)#<a href="GetDataset?ID=$1&test=$test">$1<\/a>#;
           }
           $str .= qq~<li><b>$header</b>: $result->{$key}</li>~;
        }else {
          $str .= qq~<li><b>$header</b>: $result->{$key}</li>~;
        }
      }
      $str .= "</ul>\n";


      #### Display the dataset history
      $str .= showDatasetHistory(dataset_id => $datasetID, test => $test);


      #### Provide information on several of the major data lists
      foreach my $key (qw (publicationList keywordList contactList fullDatasetLinkList)){
				if ( defined $result->{$key}){
          $header = ucfirst($key);
          $header =~  s/([A-Z][a-z]+)/$1 /g;
					$str .= "<p> <b>$header</b> </p>\n<ol>\n";     
          if ($key eq 'contactList'){
            foreach my $id (keys %{$result->{contactList}}){
              my $thisContactName = $result->{contactList}{$id}{'contact name'};
              if ( defined($thisContactName) ){
                $str .= "<b>$thisContactName</b>\n<ul>";
              } else {
                $str .= "<b>$id</b>\n<ul>";
              }
              foreach my $name (keys %{$result->{contactList}{$id}}){
                next if($name eq 'contact name');
                $str .= qq~<li>$name: $result->{contactList}{$id}{$name}</li> ~;
                $datasetSubmitter = $thisContactName if ($name eq 'dataset submitter');
                $datasetLabHead = $thisContactName if ($name eq 'lab head');
              }
              $str .= "</ul>\n";
            }
          } else {
						my @lists = split (";",  $result->{$key});
						foreach my $list(@lists){
							next if ($list !~ /\w/);
							$str .= qq~<li>$list</li>~;
						}
          }
					$str .= "</ol>\n";
        } 
      }

      if ( defined $result->{repositoryRecordList}){
        my $key = "repositoryRecordList";
        my $header = ucfirst($key);
        $header =~  s/([A-Z][a-z]+)/$1 /g;
        $str .= qq~<tr>
                   <td><b>$header</b></td><td>
                   <div id="less" onclick='toggle_more("less","more","repositoryRecordList")' >[+]</div>
                   <div id="more" onclick='toggle_less("more","less","repositoryRecordList")' style='display: none'>[-]</div> 
                    </td></tr> 
                    <ul id="repositoryRecordList" style='display: none'>
        ~;
        
        foreach my $repositoryid (keys %{$result->{repositoryRecordList}}){
          $str .= "<li>$repositoryid<ol>";
          foreach my $recordid (keys %{$result->{repositoryRecordList}{$repositoryid}}){
            if (defined $result->{repositoryRecordList}{$repositoryid}{$recordid}{Uri}){
							$str .= "<li><a href=\"$result->{repositoryRecordList}{$repositoryid}{$recordid}{Uri}\">$recordid</a><ol>"; 
            }else{ 
							$str .= "<li>$recordid<ol>";
            }
            foreach my $name (sort{$a cmp $b} keys %{$result->{repositoryRecordList}{$repositoryid}{$recordid}}){
							next if($name =~ /Uri/);
							$str .= "<li>$name: $result->{repositoryRecordList}{$repositoryid}{$recordid}{$name}</li>";
            }           
            $str .= "</ol></li>";
          }
          $str .= "</li>";
        }
        $str .= "</ul>\n";
      }     

    }

  } # end else


  if ( $pageStatus eq 'OK' && $status =~ /requested/ ) {
    $str = "ProteomeXchange dataset $title has been reserved by the $PXPartner repository for a dataset undergoing processing. However, this dataset has not yet been publicly released and announced to ProteomeXchange. Please check back later to see this dataset, or contact $PXPartner if you feel this message is in error and/or this dataset should have been released.";
    $pageStatus = 'ERROR';
  }


  #### Special handling if the output mode is XML
  if ( $outputmode =~ /XML/i ) {
    if ( $pageStatus eq 'OK' ) {

      #### If there's no filename available, error out
      if ( !defined($announcementXML) || $announcementXML eq '' ) {
	$response->{result} = "ERROR";
	$response->{message} = "no submission found for $params->{ID}\n";
	sendResponse(response=>$response);

      #### Else open and dump the file
      } else {

	#### If the file exists
	if ( -e "$path/$announcementXML" ) {
	  open (INFILE, "$path/$announcementXML" ) || die("ERROR: Unable to open $path/$announcementXML");
	  print "Content-type: text/plain\n\n";
	  my $inline;
	  while ($inline = <INFILE>) {
	    print $inline;
	  }
	  close(INFILE);

	#### Or if the file doesn't exist, error out
	} else {
	  $response->{result} = "ERROR";
	  $response->{message} = "cannot find submission file $announcementXML\n";
	  sendResponse(response=>$response);
	  return;
	}
      }
    } else {
      $response->{result} = "ERROR";
      $response->{message} = $str;
      sendResponse(response=>$response);
      return;
    }

  #### Otherwise present the information as an HTML page
  } else {
    print header ( -type => 'text/html');

    if ($pageStatus eq 'ERROR') {
      $str = "<br><b>$str</b></br></br>";
    }

    #### Print the template
    foreach my $line ( @page ){
      if($line =~ /(TEMPLATESUBTITLE|TEMPLATETITLE)/){
	my $len = 9 - length($datasetID);
	$line =~ s/$1/ProteomeXchange Dataset $title/;
	print "$line\n";
      } elsif ($line =~ /class="node-inner-padding"/) {
	#$line =~ s/>/style="padding: 0">/g;
	print "$line\n";
      } elsif ($line =~ /^<!-- BEGIN main content -->/) {
	print "$line\n";
	print qq~
						<link rel='stylesheet' id='style-css'  href='../javascript/css/patchwork.css' type='text/css' media='all' />
            <script type="text/javascript" src="$CGI_BASE_DIR/../javascript/toggle.js"></script>
 
						<div id="main">
						<div id="primary" class="site-content">
                  <div><a href='$CGI_BASE_DIR/GetDataset$teststr'> << Full experiment listing </a></div>
        ~;

	#### Show the dataset information window
	print qq~ <h1 class="entry-title"> $title </h1> ~;
	
        #### Show what the tweet message would be
	use ProteomeXchange::Tweet;
	my $tweet = new ProteomeXchange::Tweet;
	$tweet->prepareTweetContent(
          datasetTitle => $datasetTitle,
          PXPartner => $PXPartner,
          datasetIdentifier => $title,
          datasetSubmitter  => $datasetSubmitter,
          datasetLabHead => $datasetLabHead,
          datasetSpeciesString => $datasetSpeciesString,
          datasetStatus => 'new',
	);

	print qq~
                  <div class="entry-content">
                  $str
        ~;
	print "<BR><BR>".$tweet->getTweetAsHTML()."<BR><BR>";

	#### Finish the display card window
	print qq~
		  </div><!-- #content -->
		  </div><!-- #primary .site-content -->
		  </div><!-- #main -->
        ~;

      } else {
	print "$line\n";
      }

    }
  }

} # end showDataset


###############################################################################
# build_SQL_columns_list
###############################################################################
sub build_SQL_columns_list {
  my %args = @_;
  my $METHOD = 'build_SQL_columns_list';
  #### Process the arguments list
  my $column_array_ref = $args{'column_array_ref'} ||
    die "$METHOD: column_array_ref not passed!";
  my $hidden_cols_ref = $args{'hidden_cols_ref'};
  my $heading = $args{'heading'};

  my $columns_clause = "";
  my $element;
  foreach $element (@{$column_array_ref}) {
    next if ( defined $hidden_cols_ref->{$element->[1]});
    $columns_clause .= "," if ($columns_clause);
    $columns_clause .= "$element->[0]";

    push @$heading , $element->[1];
  }
  #### Return result
  return $columns_clause;

} # end build_SQL_columns_list


###############################################################################
# showDatasetHistory
###############################################################################
sub showDatasetHistory {
  my %args = @_;
  my $SUB_NAME = 'showDatasetHistory';

  #### Decode the argument list
  my $outputMode = $args{outputMode} || '';
  my $test = $args{test} || 'no';
  my $dataset_id = $args{dataset_id} || die("[$SUB_NAME] ERROR: dataset_id not passed");
  my $str = '';

  my $tableName = "datasetHistory";
  $tableName .= "_test" if ($test =~ /yes|true/i);

  $str .= "<p><b>Dataset History</b></p>\n";
  #$str .= "test=$test  tableName=$tableName<BR>\n";

  $str .= "<table class=\"table\" cellpadding=\"2\">\n";

  my $sql = "SELECT dataset_id,datasetIdentifier,identifierVersion,isLatestVersion,PXPartner,status,primarySubmitter,title,species,instrument,publication,keywordList,announcementXML,identifierDate,submissionDate,revisionDate,changeLogEntry FROM $tableName WHERE dataset_id = $dataset_id";

  my $db = new ProteomeXchange::Database;

  #### Get the data from the database
  #### If the table is missing, this leads to a silent crash! FIXME
  my @rows = $db->selectSeveralColumns($sql);

  my $nRows = scalar(@rows);
  if (@rows) {
    #print "Successfully selected $nRows rows\n";
  } else {
    $str .= "<tr><td>History information is not currently available for this dataset</td></tr>\n";
    $str .= "</table>\n";
    return $str;
  }

  $str .= "<tr>";
  foreach my $item ( 'Version','Datetime','Status','ChangeLog Entry' ) {
    $str .= "<td class=\"tableTitle\">$item</td>";
  }
  $str .= "</tr>\n";

  foreach my $row ( @rows ) {
    my ( $dataset_id,$datasetIdentifier,$identifierVersion,$isLatestVersion,$PXPartner,$status,$primarySubmitter,$title,$species,$instrument,$publication,$keywordList,$announcementXML,$identifierDate,$submissionDate,$revisionDate,$changeLogEntry ) = @{$row};

    $str .= "<tr>";
    foreach my $item ( $identifierVersion,$revisionDate||$submissionDate||$identifierDate,$status,$changeLogEntry ) {
      $item = '' unless (defined($item));
      $str .= "<td class=\"tableText\">$item</td>";
    }
    $str .= "</tr>\n";

  }
  $str .= "</table>\n";

  return $str;
}





